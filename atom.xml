<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Darkの小站</title>
  <icon>https://www.gravatar.com/avatar/6ebc93b324a863687909982a727f4ae2</icon>
  <subtitle>欢迎光临我的小站～～～</subtitle>
  <link href="https://linzeliang.top/atom.xml" rel="self"/>
  
  <link href="https://linzeliang.top/"/>
  <updated>2021-09-24T14:48:56.886Z</updated>
  <id>https://linzeliang.top/</id>
  
  <author>
    <name>林泽良</name>
    <email>linzeliang1222@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap源码剖析</title>
    <link href="https://linzeliang.top/post/41456.html"/>
    <id>https://linzeliang.top/post/41456.html</id>
    <published>2021-09-24T14:42:52.000Z</published>
    <updated>2021-09-24T14:48:56.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-HashMap继承结构"><a href="#1-HashMap继承结构" class="headerlink" title="1. HashMap继承结构"></a>1. HashMap继承结构</h3><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632487670.png" alt="image-20210924204750139"></p><h3 id="2-HashMap底层数据结构"><a href="#2-HashMap底层数据结构" class="headerlink" title="2. HashMap底层数据结构"></a>2. HashMap底层数据结构</h3><p>在1.7及其之前，<code>HashMap</code>底层是使用 数组 + 链表实现的，在1.8及其之后，使用了 数组 + 链表/红黑树 实现。</p><p>来看下1.7的储存结构图：</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632485062.png" alt="image-20210924200421961"></p><p>其中链表使用内部类Node来实现的：</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632487826.png" alt="image-20210924205026504"></p><p><strong>数组+链表（散列表）</strong> 其实就是用于解决哈希冲突使用的一个<code>拉链法</code>方法。<strong>在数据结构中，我们处理hash冲突常使用的方法有：开发定址法、再哈希法、链地址法、建立公共溢出区。而HashMap中处理hash冲突的方法就是链地址法。</strong></p><p>但是这样子的话，如果使用了很久，HashMap存储的元素越来越多，那么链表就会变的很长，那么<strong>性能就会下降很多</strong>（因为链表不适合查找元素，每次查找元素都要从头开始遍历）。</p><p>于是在1.8的时候进行了改进，使用到了<strong>红黑树</strong>（红黑树是一个自平衡的二叉查找树，查找效率是非常高，时间复杂度仅为O(logN)）。</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632486698.png" alt="image-20210924203138870"></p><p>在HashMap中，链表转化成红黑树的条件是当<strong>链表长度大于8</strong>且<strong>数组(桶)的个数要大雨等于64个</strong>时，才可以将链表转化成红黑树，它们在源码中的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 转化成红黑树的最小的桶容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 桶上的元素的数量</span></span><br></pre></td></tr></table></figure><p>treeifyBin中的片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 意思是只要桶的个数小于64个，那么即使桶中的元素个数超过了8个，那么就进行resize扩容，而不是转化成红黑树</span></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)  </span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>putVal中的片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// -1 for 1st 可以理解为元素下表从-1开始的，所以可以看作binCount &gt;= 9</span></span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">        treeifyBin(tab, hash);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-HashMap的属性"><a href="#3-HashMap的属性" class="headerlink" title="3. HashMap的属性"></a>3. HashMap的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量，左移位4位相当于：1*2*2*2*2=16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大的容量：2的30次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认装载因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当一个元素被添加到至少有8个节点的桶中，桶中的链表将会被转化成红黑树，即转化成红黑树条件是大于8个</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树退化成链表的条件：小于等于6时退化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化成红黑树的最小的桶的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>成员属性有如下：</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632487601.png" alt="image-20210924204641256"></p><h3 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h3><p>一共有4个构造方法：</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632490501.png" alt="image-20210924213501347"></p><p>其中，核心的构造方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证初始容量大于等于0，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="comment">// 保证初始容量不大于最大容量，超过了就讲初始容量设置为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 保证装载因子大于0</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="comment">// 初始化装载因子为0.75</span></span><br><span class="line">    <span class="comment">// 当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// threshold这个成员变量是阈值，决定了是否要将散列表再散列，它的值应该是：capacity * load factor</span></span><br><span class="line">    <span class="comment">// 但是这里的threshold并不是真正的初始化阈值，正在的初始化阈值时在resize的时候进行初始化（而此时的threshold并不是没有用，而是待会在初始化容量时候要用的初始值）</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化阈值容量的时候，调用了<code>tableSizeFor</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法返回大于输入数字的最近的2的整数次幂的数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-put方法"><a href="#5-put方法" class="headerlink" title="5. put方法"></a>5. put方法</h3><p>put方法其实是调用了putVal方法的，调用方法的同时把计算好的key的哈希值传入，putVal方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put的<strong>过程如下</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; <span class="comment">// tab表示的是哈希数组</span></span><br><span class="line">Node&lt;K,V&gt; p; <span class="comment">// p表示的是数组的第一个节点</span></span><br><span class="line">Node&lt;K,V&gt; e; <span class="comment">// e表示该key是否已经存在，为null表示不存在</span></span><br></pre></td></tr></table></figure><ol><li><p>put方法接收传入key与value：<code>put(K key, V value)</code></p></li><li><p>计算出key的哈希值，这里计算的哈希值方法是key的hashcode与hashcode的高16位进行异或运算得到的结果</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将计算得到的哈希值、key、value传给putVal方法</p></li><li><p>在putVal方法中，先判断哈希数组是否为空，如果为空的话就resize初始化tab，创建新的数组</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断tab是否为空</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></li><li><p>如果存在哈希表，则计算key对应的索引位置：<code>p = tab[i = (n - 1) &amp; hash</code>，使用<code>length-1</code>与<code>hash</code>进行逻辑与运算（因为在做<code>&amp;</code>运算的时候，<strong>仅仅是后4位有效</strong>，那么如果key的哈希值<strong>低位变化不大，高位变化大</strong>，那么在计算的时候发生哈希冲突的可能性也增大许多，所以上面在计算哈希的时候将hash与hash的高16为进行异或运算得到结果作为哈希值，增加了<strong>随机性</strong>），如果改索引位置还没有节点，那么就直接插入到该位置即可！</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果该桶上有元素的话，就根据该桶的结构是红黑树还是链表进行插入，然后返回结果赋值给<code>e</code>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    <span class="comment">// 是树形结构按照树形结构插入</span></span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 按照链表结构插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 判断是否要转化成红黑树结构</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果e是为<code>null</code>，就说明该key不存在，直接插入，如果不为<code>null</code>，说明key已经存在，直接将覆盖原来的value，并返回</p></li><li><p>插入成功之后，还要判断一下实际存在的键值对的数量<code>size</code>是否大于阈值<code>threshold</code>，如果大于那么就扩容</p></li></ol><h3 id="6-扩容"><a href="#6-扩容" class="headerlink" title="6. 扩容"></a>6. 扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>先判断原来的容量是否大于0</p></li><li><p>如果大于0的话且大于等于最大容量，就将阈值设置为Integer.MAX_VALUE，然后啥也不干</p><p> 如果大于0的话且小于于最大容量就将旧的容量扩容为原来的两倍，同时也将旧的阈值扩大为原来的两倍</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果初始容量未制定或者小于等于0（就是HashMap构造方法的那种情况，只初始化了threshold阈值），那么就将阈值作为初始化容量（此时阈值是2的整数次幂，HashMap的容量要为2的整数次幂）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br></pre></td></tr></table></figure></li><li><p>剩下的情况就是初始容量没有设定，阈值也没有设定，那么容量就用默认的<code>DEFAULT_INITIAL_CAPACITY</code>，阈值则为：<code>(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果新容量的阈值为设定，那么就设定下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>刷新当前容量的阈值</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = newThr;</span><br></pre></td></tr></table></figure></li><li><p>最后就是将旧的数据复制到新数组里面，有两种情况：</p><ol><li>扩容后，若hash值新增参与运算的位=0，那么元素在扩容后的位置=原始位置</li><li><p>扩容后，若hash值新增参与运算的位=1，那么元素在扩容后的位置=原始位置+扩容后的旧位置</p><p>扩容后长度为原hash表的2倍，于是把hash表分为两半，分为低位和高位，如果能把原链表的键值对， 一半放在低位，一半放在高位，而且是通过<code>e.hash &amp; oldCap == 0</code>来判断。因此有50%的概率放在新hash表低位，50%的概率放在新hash表高位。</p></li></ol></li></ol><h3 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7. get方法"></a>7. get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法的实现就是计算key的hash值，然后通过getNode获取对应的value</p><h3 id="8-remove方法"><a href="#8-remove方法" class="headerlink" title="8. remove方法"></a>8. remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove方法也是通过计算key的hash，调用removeNode来删除元素的</p><h3 id="9-HashMap的一些特性"><a href="#9-HashMap的一些特性" class="headerlink" title="9. HashMap的一些特性"></a>9. HashMap的一些特性</h3><ul><li>允许key和value为null</li><li>除了允许为努力了和同步，其他的和HashTable一样</li><li>不保证有序</li><li>初始容量太高或者太低对便利都不太好</li><li>当哈希表容量超过初始容量<em>装载因子时，哈希表会进行再散裂，桶数量\</em>2</li><li>不同步，想要同步可以使用Collections工具类实现<code>Map m = Collections.synchronizedMap(new HashMap(...));</code></li><li>装载因子默认是0.75，设置高虽然会减少空间，但是遍历的开销会增加。因此在设置初始容量时，应该考虑好装载因子和容量的大小，如果设置的好，就不用再散裂了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java基础" scheme="https://linzeliang.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://linzeliang.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 144. 二叉树的前序遍历</title>
    <link href="https://linzeliang.top/post/49364.html"/>
    <id>https://linzeliang.top/post/49364.html</id>
    <published>2021-05-31T03:04:51.000Z</published>
    <updated>2021-05-31T06:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><h2 id="思路1（递归）"><a href="#思路1（递归）" class="headerlink" title="思路1（递归）"></a>思路1（递归）</h2><ul><li>前序先遍历根节点，然后左孩子，然后右孩子</li><li>使用递归解题</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$，其中 N 为二叉树的结点数</li><li>空间复杂度：$O(N)$</li></ul><h2 id="思路2（迭代）"><a href="#思路2（迭代）" class="headerlink" title="思路2（迭代）"></a>思路2（迭代）</h2><ul><li>用栈来遍历</li><li>和层序遍历有些类似，不过不用队列，而是用栈</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                <span class="comment">// 入栈</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop().right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$，其中 N 为二叉树的结点数</li><li>空间复杂度：$O(N)$</li></ul><h2 id="思路3（Morris遍历）"><a href="#思路3（Morris遍历）" class="headerlink" title="思路3（Morris遍历）"></a>思路3（Morris遍历）</h2><ul><li>如果左孩子不为空<ul><li>找到左子树的最右端的节点<ul><li>如果该节点的right是null，那么将其right指向当前节点，并且将当前节点加入res</li><li>否则将其right置为null</li></ul></li></ul></li><li>如果左孩子为空<ul><li>直接将当前节点加入res</li></ul></li><li>每次循环结束都将指针指向当前节点的右孩子right</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode p1 = root;</span><br><span class="line">        TreeNode p2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p2 = p1.left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2.right != <span class="keyword">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class="line">                    p2 = p2.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(p1.val);</span><br><span class="line">                    <span class="comment">// 如果左子树的最右节点是指向空的，那么就先把他指向子树的父节点</span></span><br><span class="line">                    p2.right = p1;</span><br><span class="line">                    <span class="comment">// 同时指针 </span></span><br><span class="line">                    p1 = p1.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(p1.val);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$，其中 N 为二叉树的结点数</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 142. 环形链表 II</title>
    <link href="https://linzeliang.top/post/47975.html"/>
    <id>https://linzeliang.top/post/47975.html</id>
    <published>2021-05-20T07:42:13.000Z</published>
    <updated>2021-05-21T07:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p><h2 id="思路1（哈希表）"><a href="#思路1（哈希表）" class="headerlink" title="思路1（哈希表）"></a>思路1（哈希表）</h2><ul><li>利用哈希表HashSet，保存访问过的路径，如果未访问过，就add添加且返回true，如果已存在再添加的话就会返回该结点，而且该结点就是他们重合的结点，否则返回null</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//利用哈希表不重复元素的特性来存储结点判断是否存在环</span></span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要没到头且还没重合就一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到末尾还是没有重合的话就是返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li></ul><h2 id="思路2（双指针）"><a href="#思路2（双指针）" class="headerlink" title="思路2（双指针）"></a>思路2（双指针）</h2><ul><li><p>我们可以利用快慢指针，慢指针每次移动一个，快指针每次移动两个，如果确实存在环的话，最终一定会重合的</p></li><li><p>如果快指针最后为<code>null</code>，肯定是到末尾了，就没有环</p></li><li><p>我们假设头结点到重合的结点这段长度为a，重合的结点到相遇的结点为<code>b</code>，环的剩下部分为<code>c</code></p><ul><li>由于再相同的时间内，<code>fast</code>的速度是<code>low</code>的两倍，而<code>low</code>走的路程为<code>a+b</code>，<code>fast</code>为<code>low</code>的两倍那么路程应该是`2(a+b)``</li><li>由题分析可得，fast走过的长度为<code>a+b+c+b</code></li><li>可得等式：<code>a+b+c+b = 2(a+b)</code> ，得到<code>c = a</code></li><li>所以，我们可以等到相遇的时候再创建一个指向<code>head</code>的指针，同时以相同的速度向前移动，等到相遇的时候就是我们要的环重合的结点</li></ul><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/142_fig1.png" alt=""></p></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义快慢指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若为空或者只有一个元素时候就是无环的</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">//如果快慢指针重合就代表存在环，然后开始寻找重合点</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="comment">//定义一个pre指针指向head，让pre和low同时移动，等到重合时就是指向重合的点</span></span><br><span class="line">                ListNode pre = head;</span><br><span class="line">                <span class="keyword">while</span> (pre != slow) &#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂的分析"><a href="#复杂的分析" class="headerlink" title="复杂的分析"></a>复杂的分析</h3><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 160. 相交链表</title>
    <link href="https://linzeliang.top/post/21905.html"/>
    <id>https://linzeliang.top/post/21905.html</id>
    <published>2021-05-19T09:47:11.000Z</published>
    <updated>2021-05-20T03:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p><h2 id="思路1（暴力）"><a href="#思路1（暴力）" class="headerlink" title="思路1（暴力）"></a>思路1（暴力）</h2><ul><li>暴力遍历</li><li>当遍历其中一个链表每一个元素时，都将该元素和另一个链表的每一个元素进行比较，如果相等就相交。时间复杂度比较大。。。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode p = headB;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == headA) &#123;</span><br><span class="line">                    <span class="keyword">return</span> headA;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(MN)$，其中 M、N 为链表的长度</li><li>空间复杂度：$O(1)$</li></ul><h2 id="思路2（哈希表）"><a href="#思路2（哈希表）" class="headerlink" title="思路2（哈希表）"></a>思路2（哈希表）</h2><ul><li>使用哈希表，其中一个链表存到哈希表中，然后遍历另一个链表，将其添加到原来的哈希表中，如果存在，就是找到相交的结点了</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(headB)) &#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(M+N)$，其中 M、N 为链表的长度</li><li>空间复杂度：$O(N)或O(M)$，其中 M、N 为链表的长度</li></ul><h2 id="思路3（双指针）"><a href="#思路3（双指针）" class="headerlink" title="思路3（双指针）"></a>思路3（双指针）</h2><ul><li>我们可以将另一端链表虚拟拼接（如果实际改变指针的话会导致死循环）到本段链表后面（null不要省略），两个链表此时时灯等长的。然后两个链表同时从头开始遍历，如果存在相交的结点，那么<code>p1 != p2</code>就不会成立，因此找到答案，退出循环；如果没有找到答案，最后都会为null，同样跳出循环，得到结果</li><li>例1（相交）：<ul><li>headA={4, 2, 8, 4, 5}，headB={5, 0, 1, 8, 4, 5}，虚拟拼接后为：</li><li>headA={4, 2, 8, 4, 5, null, 5, 0, 1, 8, 4, 5, null}，headB={5, 0, 1, 8, 4, 5, null, 4, 2, 8, 4, 5, null}</li><li>当索引为9时，结点都是8，此时退出循环，找到答案</li></ul></li><li>例2（不相交）：<ul><li>headA={1, 2, 3}，headB={4, 3, 2, 1}，虚拟拼接后为：</li><li>headA={1, 2, 3, null, 4, 3, 2, 1, null}，headB={4, 3, 2, 1, null, 1, 2, 3, null}</li><li>当索引为8时，两个指针都指向null，此时也退出循环，不过返回的时null，即没有找到答案</li></ul></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果其中一个存在空链表，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="comment">// 当还没相遇时，一直遍历下取，如果两个都没有相遇，最终都为null，那么也会退出循环</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(M+N)$，其中 M、N 为链表长度</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 109. 有序链表转换二叉搜索树</title>
    <link href="https://linzeliang.top/post/60772.html"/>
    <id>https://linzeliang.top/post/60772.html</id>
    <published>2021-05-18T04:24:53.000Z</published>
    <updated>2021-05-21T07:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></p><h2 id="思路1（分治-前序）"><a href="#思路1（分治-前序）" class="headerlink" title="思路1（分治+前序）"></a>思路1（分治+前序）</h2><ul><li>二叉搜索树就是左孩子比根节点小，右孩子比根节点大，而且左右两个子树的高度差不大于1称为二叉搜索树</li><li>通过观察这个链表转换成的搜索树可以发现，根节点其实就是链表的中间的结点，左孩子就是左边一半链表的中间的结点，右孩子就是右边一半链表的中间的结点</li><li>所以可以利用递归（自顶向下）方法来解题，递归的截止条件就是遍历到本段链表末尾</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(slow.next);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(NlogN)$，其中 N 为链表的长度。</li><li>空间复杂度：$O(logN)$，其中logN为树的深度，递归时所创建的空间</li></ul><h2 id="思路2（分治-中序）"><a href="#思路2（分治-中序）" class="headerlink" title="思路2（分治+中序）"></a>思路2（分治+中序）</h2><ul><li>我们只需要在分治的过程中不断进行分治，直到<code>left&gt;right</code>，且在这过程中不需要找出链表的中位结点，而是先用一个空值的节点栈为构建一颗二叉树雏形</li><li>等到中序遍历遍历到该结点时，再进行值的填充</li><li>因为链表的结果是升序的，而二叉搜索树的中序遍历也是升序的，所以<code>globalHead = globalHead.next</code>就可以有序地填充树的节点的值</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode globalHead;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        globalHead = head;</span><br><span class="line">        <span class="comment">// 获取链表长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行递归中序遍历构建树</span></span><br><span class="line">        <span class="keyword">return</span> inorderBuild(<span class="number">0</span>, length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderBuild</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取中位数</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先构建空值的节点占位</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树遍历</span></span><br><span class="line">        root.left = inorderBuild(left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 进行节点的填充</span></span><br><span class="line">        root.val = globalHead.val;</span><br><span class="line">        globalHead = globalHead.next;</span><br><span class="line">        <span class="comment">// 右子树遍历</span></span><br><span class="line">        root.right = inorderBuild(mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$，其中 N 是链表长度</li><li>空间复杂度：$O(logN)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 24. 两两交换链表中的节点</title>
    <link href="https://linzeliang.top/post/7578.html"/>
    <id>https://linzeliang.top/post/7578.html</id>
    <published>2021-05-17T00:43:12.000Z</published>
    <updated>2021-05-17T00:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><ul><li>链表可以创建一个头结点来辅助解题，再创建一个指针指向头结点（该指针是把链表连起来用的），然后按照1指向3、2指向1完成交换，指针也下移两位，一直循环，直到刚好交换完或者剩下一个结点时候结束循环，完成交换</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链表一般可以考虑创建一个头结点来辅助解题</span></span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = newHead;</span><br><span class="line">        <span class="comment">//将头指针指向下一个要排序的head</span></span><br><span class="line">        cur.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刚好交换完或者剩下一个结点时候结束循环</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//改变指针指向交换后的左结点</span></span><br><span class="line">            cur.next = head.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            head.next = head.next.next;</span><br><span class="line">            cur.next.next = head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//两个指针都移动后两位</span></span><br><span class="line">            cur = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回第一个结点</span></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><ul><li>递归实现，下一次递归传递的是要交换的第一个结点，若还有结点，就继续递归。我们可以从后往前看，将交换完的链表返回给前一个调用该函数的他的next，然后依次推导，最后返回头结点（<strong>注意，返回的要是第二个结点，因为第一个结点和第二个结点交换完后第二个就变成了第一个结点了</strong>）</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//刚好交换完或者剩下一个结点时候结束递归</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录第二个结点的</span></span><br><span class="line">        ListNode p1 = head.next;</span><br><span class="line">        <span class="comment">//第一个结点的下一个为交换好后的链表</span></span><br><span class="line">        head.next = swapPairs(p1.next);</span><br><span class="line">        <span class="comment">//必须要放到执行swapPairs函数后面执行，否则如果先执行，那么函数里面的p1.next就指错了，造成栈溢出</span></span><br><span class="line">        p1.next = head;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 739. 每日温度</title>
    <link href="https://linzeliang.top/post/60463.html"/>
    <id>https://linzeliang.top/post/60463.html</id>
    <published>2021-05-16T16:36:19.000Z</published>
    <updated>2021-05-17T00:05:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></p><h2 id="思路1（暴力破解）"><a href="#思路1（暴力破解）" class="headerlink" title="思路1（暴力破解）"></a>思路1（暴力破解）</h2><ul><li>遍历每一个元素，从他的后一个元素开始寻找比他大的元素，如果遇到的是比他小于等于的，那就跳过，继续往后找</li><li>如果找到最后一个都还没找到比他大的，那么就直接赋值为0</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; T.length &amp;&amp; T[i] &gt;= T[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != T.length) &#123;</span><br><span class="line">                res[i] = j - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N^2)$，其中 N 为数组的长度</li><li>空间复杂度：$O(N)$，其中 N 为数组的长度</li></ul><hr><h2 id="思路2（单调栈）"><a href="#思路2（单调栈）" class="headerlink" title="思路2（单调栈）"></a>思路2（单调栈）</h2><ul><li>由于是找到最近的比当前温度高的距离，所以可以使用<strong>单调递增栈</strong></li><li>只有当前温度大于栈顶温度，那么才将栈元素出栈，直到小于栈元素才停止，否则的话，直接入栈</li><li>我们的单调栈中寸的是索引<code>index</code>，而不是元素的值，这样计算距离时直接用index相减即可得到结果</li><li>比较当前元素值和栈顶元素值大小，只要栈顶元素值小于当前元素值，那么<code>当前元素的索引</code> - <code>栈顶元素的索引</code>就是比栈顶元素值大的下一个元素的距离</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">         Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">         <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">             <span class="comment">// 新的元素值只要比栈顶元素大，就要将栈顶元素出栈</span></span><br><span class="line">             <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                 <span class="keyword">int</span> peek = stack.pop();</span><br><span class="line">                 res[peek] = i - peek;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 然后将此元素的索引存入stack中</span></span><br><span class="line">             stack.push(i);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 61. 旋转链表</title>
    <link href="https://linzeliang.top/post/17743.html"/>
    <id>https://linzeliang.top/post/17743.html</id>
    <published>2021-05-16T11:33:45.000Z</published>
    <updated>2021-05-17T00:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a></p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><ul><li>可以将链表首位相连接，变成一个循环链表</li><li>再通过<code>len - k % len</code>可得出需要将指向head的引用往后移动多少，将head前一个（即新的链表的尾部）的next指向null，最后返回head即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果出现链表为空、链表的元素只有一个、k为0，那么就直接返回head</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算链表的长度</span></span><br><span class="line">        ListNode oldHead = head;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (oldHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldHead = oldHead.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        oldHead.next = head;</span><br><span class="line">        <span class="comment">//减1是为了只获取到新的头结点前一个结点</span></span><br><span class="line">        k = len - k % len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newHead = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂的分析"><a href="#复杂的分析" class="headerlink" title="复杂的分析"></a>复杂的分析</h3><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><ul><li>利用双指针，先求出总的链表长度len，再在不超过链表的长度的移动距离<code>k = k % len</code>，然后让fast指针后移k个位置，然后将快慢指针同时后移，直到fast指针到达最后一个结点停止移动。然后用newHead引用记录low.next这个结点（就是我们新链表的头结点），将fast.next指向head，low.next指向null，最后返回newHead即可</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果出现链表为空、链表的元素只有一个、k为0，那么就直接返回head</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先定义快、慢指针</span></span><br><span class="line">        ListNode low = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">//临时的指针</span></span><br><span class="line">        ListNode tmp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算链表的总长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移动的距离不超过链表的长度</span></span><br><span class="line">        k = k % len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动fast指针k长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针同时移动</span></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            low = low.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fast.next = head;</span><br><span class="line">        ListNode newHead = low.next;</span><br><span class="line">        low.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂的分析-1"><a href="#复杂的分析-1" class="headerlink" title="复杂的分析"></a>复杂的分析</h3><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>浅谈单调栈</title>
    <link href="https://linzeliang.top/post/39310.html"/>
    <id>https://linzeliang.top/post/39310.html</id>
    <published>2021-05-15T18:02:44.000Z</published>
    <updated>2021-05-17T00:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是单调栈？"><a href="#什么是单调栈？" class="headerlink" title="什么是单调栈？"></a>什么是单调栈？</h2><ul><li>单调栈实际上就是栈，只是限制要比普通的栈更严格而已了。要求是每次入栈的元素必须要有序（如果新元素入栈不符合要求，则将之前的元素出栈，直到符合要求再入栈），使之形成<strong>单调递增/单调递</strong>减的一个栈。</li></ul><p>比如我们有一个数组：</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/2067154-20201108091900872-437468476.png" alt=""></p><ul><li><strong>单调递增栈：</strong>只有比他小的才直接入栈，如果大于就先出栈再入栈（<strong>在出栈的时候可以进行一些操作计算</strong>，如求温度那一题就是在出栈时候计算第一个大于该值他们之间的距离）。适用于求解第一个大于该位置元素的数</li><li><strong>单调递减栈：</strong>只有比他大的才入栈，如果小于的话，也是先出栈再入栈。适用于求第一个小于该位置元素的数</li><li>如何判断是 单调<strong>递增/递减</strong>栈 是按照出栈的顺序决定的，比如栈为 {1, 2, 6}，出栈后，为{6, 2, 1}，这是递减顺序的，所以就是单调递减栈了</li><li><strong>总结：如果要的结果是递减的，则用到单调递增栈；如果结果是递增的，则需要用到单调递减栈</strong></li></ul><p>单调栈适合的题目是求解 <strong>第一个大于 xxx</strong> 或者 <strong>第一个小于 xxx</strong> 这种题目。当出现类似题目时候应该优先想到使用单调栈来解题。</p><p><hr></p><h2 id="举一个的例子："><a href="#举一个的例子：" class="headerlink" title="举一个的例子："></a>举一个的例子：</h2><ul><li><strong>比如我们要将数组 {1, 3, 4, 5, 2, 9, 6} 压入栈：</strong></li></ul><ol><li>首先1入栈，此时栈为：{1}</li><li>接下来是3，由于 3 &gt; 1 ，直接入栈，此时栈为：{1, 3}</li><li>接下来是4，由于 4 &gt; 3 ，直接入栈，此时栈为：{1, 3, 4}</li><li>接下来是5，由于 4 &gt; 3 ，直接入栈，此时栈为：{1, 3, 4, 5}</li><li><strong>接下来</strong>是2，因为 2 &lt; 5，不满足条件，所以我们将5出栈，此时栈为：{1, 3, 4}</li><li>然后再将2与4比较，因为 2 &lt; 4 ，还是不满足条件，所以再将4出栈，此时栈为：{1, 3}</li><li>然后再将2与3比较，因为 2 &lt; 3 ，还是不满足条件，所以再将3出栈，此时栈为：{1}</li><li>然后将2与1比较，因为 2 &gt; 1 ，满足条件，将2入栈，此时栈为：{1, 2}</li><li>接下来是9，由于 9 &gt; 2 ，直接入栈，此时栈为：{1, 2, 9}</li><li><strong>接下来</strong>是6，因为 6 &lt; 9 ，不满足条件，将9出栈，此时栈为：{1, 2}</li><li>然后6与2比较，6 &gt; 2 ，满足条件，6入栈，此时栈为{1, 2, 6}</li><li>最后，目标数组都遍历完了，我们就得到了该结果</li></ol><p><hr></p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><ul><li>给你一个数组，返回一个等长的数组，对应索引存储着下一个更大的元素，如果没有更大的元素，就存-1。这个要怎么解呢？<ul><li>如果输入的是{2, 1, 2, 4, 3}，那么我们会得到结果{4, 2, 4, -1, -1}</li><li>这个结果是怎么得来的捏？向右扫描，比2大的第一个数是4，比1大的第一个数是2，没有比4大的数(4 &gt; 3)，也没有比3大的数(3 == 3)，所以这两个为-1</li></ul></li></ul><p>可以尝试一下做下这一题：<a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></p><p>经过多次做题总结，不难发现，其实是有<strong>套路模板</strong>的，以后做题只需要修改一些即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] monotonousStack(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用来存放第一个大于该位置元素的距离</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> peek = stack.pop();</span><br><span class="line">                <span class="comment">// i - peek 是求解在peek的右边中，第一个大于T[peek]的元素</span></span><br><span class="line">                res[peek] = i - peek;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>「复杂度分析」</strong></p><ul><li>时间复杂度：由于数组的元素最多只会入栈，出栈一次，因此时间复杂度仍然是$O(N)$ ，其中 N 为数组长度</li><li>空间复杂度：由于使用了栈， 并且栈的长度最大是和数组长度一致，因此空间复杂度是 $O(N)$，其中 N 为数组长度</li></ul><p>对于有些时候，如果会用到数组的<strong>全部元素</strong>，即栈中的元素最后都要出栈，那么很可能因为没有考虑边界而无法通过。所以我们可以使用 <strong>哨兵法</strong> ，在 {1, 3, 4, 5, 2, 9, 6} 末尾添加一个 -1 作为哨兵，变成了 {1, 3, 4, 5, 2, 9, 6, -1} ，这种技巧可以简化代码逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法知识" scheme="https://linzeliang.top/tags/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>768. 最多能完成排序的块 II</title>
    <link href="https://linzeliang.top/post/36314.html"/>
    <id>https://linzeliang.top/post/36314.html</id>
    <published>2021-05-15T13:52:44.000Z</published>
    <updated>2021-05-17T00:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用<strong>单调递减栈</strong>来解题<ul><li>遍历数组，将元素存入栈中，再利用max记录当前栈顶的最大值</li><li>如果遇到比当前栈元素大的值，那么可以<strong>直接入栈</strong>，因为可以单独分一块；但是如果遇到比当前栈顶元素小的值，那么应该将之前的元素<strong>依次出栈</strong>，直到遇到<strong>小于等于</strong>该值的元素停止出栈，然后将max再push入栈（push的这个max就代表了这一个块）<ul><li>例如：有该数组 {1, 1, 3, 4, 5, 2, 6, 7}，此时栈为{1, 1, 3, 4, 5}</li><li>接下来遍历到2了，2比max即5小，所以开始出栈，顺序是：5、4、3，由于1小于2，所以停止出栈，接下来将max(5)入栈，此时栈为：{1, 1, 5}</li></ul></li><li>不断遍历，直到数组遍历结束，此时栈中有多少个元素就代表有多少个块了</li></ul></li><li>分块规则：<strong>后一块元素的最小值大于等于前一块元素的最大值</strong></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span>  LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[max]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]) &#123;</span><br><span class="line">                    stack.pop() ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此处不能stack.push(i)，push的必须是这一组的最大值</span></span><br><span class="line">                stack.push(max);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                max = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$， N 为数组长度</li><li>空间复杂度：$O(N)$，N为栈的大小</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 232. 用栈实现队列</title>
    <link href="https://linzeliang.top/post/59996.html"/>
    <id>https://linzeliang.top/post/59996.html</id>
    <published>2021-05-14T14:32:11.000Z</published>
    <updated>2021-05-15T17:33:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><ul><li>即然是使用两个栈，那么一个栈就用来做辅助栈，一个栈用来存元素</li><li>我们将栈顶作为队头，将栈底作为队尾，所以如果要push数据的话，先将stack1栈的数据暂时存到stack2辅助栈中，然后将要插入的数据push进入stack1，最后再将stack2的暂存的数据填回到stack1中<strong>（注意，回填元素时顺序不能乱）</strong></li><li>pop时，就是将栈的元素最后一个pop出去，由于我们将队头做为栈顶，所以stack1的pop其实就是出队操作</li><li>empty：要判断队列是否为空，直接判断stack1是否为空即可</li><li>由于栈是基于LinkedList实现的，peek时即查看的是栈顶的元素，所以直接peek就是查看队头的元素</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; mainStack;</span><br><span class="line">    Deque&lt;Integer&gt; helpStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        helpStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!mainStack.isEmpty()) &#123;</span><br><span class="line">            helpStack.push(mainStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        mainStack.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!helpStack.isEmpty()) &#123;</span><br><span class="line">            mainStack.push(helpStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mainStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mainStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：<ul><li>push: $O(N)$</li><li>pop: $O(1)$</li><li>peek: $O(1)$</li><li>empty: $O(1)$</li></ul></li><li>空间复杂度：$O(N)$</li></ul><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><ul><li>我们将一个栈用作进栈<code>inStack</code>，另一个栈用作<code>outStack</code></li><li>因为是将<code>inStack</code>的中的所有元素<code>pop</code>出来，<code>push</code>到<code>outStack</code>中去，则发生位置反转，所以<code>outStack</code>的栈顶元素就是我们队列的队头</li><li>出队元素的话只需要从<code>outStack</code>中将栈顶元素<code>pop</code>即可</li><li>如果<code>outStack</code>是 空的，就需要将<code>inStack</code>中的所有元素移动到<code>outStack</code>中去</li><li><strong>注意：如果<code>outStack</code>中如果不是空的，不能将<code>inStack</code>中的元素移过去，否则顺序被打乱</strong></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; inStack;</span><br><span class="line">    Deque&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为inStack作用就是用于进栈，所以无需其他判断条件</span></span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果outStack是空的，那么就需要将inStack中的元素移动到outStack中去，然后再pop</span></span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            move();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            move();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有两个栈都是空的，就说明队列是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将inStack中的元素移动到outStack中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：<ul><li>push: $O(1)$</li><li>pop: $O(N)$</li><li>peek: $O(N)$</li><li>empty: $O(1)$</li></ul></li><li>空间复杂度：$O(N)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 104. 二叉树的最大深度</title>
    <link href="https://linzeliang.top/post/33781.html"/>
    <id>https://linzeliang.top/post/33781.html</id>
    <published>2021-05-13T15:58:13.000Z</published>
    <updated>2021-05-15T17:33:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><h2 id="思路1（递归）"><a href="#思路1（递归）" class="headerlink" title="思路1（递归）"></a>思路1（递归）</h2><ul><li>自顶向下，利用递归</li><li>从子结构中择优，选择最大的那个</li><li>其实就是树的后序遍历</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到底就开始返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取左右子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 择优</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$，其中 N 为树的结点数量</li><li>空间复杂度：$O(N)$，其中 N 为树的最大高度</li></ul><h2 id="思路2（迭代）"><a href="#思路2（迭代）" class="headerlink" title="思路2（迭代）"></a>思路2（迭代）</h2><ul><li>使用迭代方法来做，利用队列实现</li><li>队列存储的是每一层的所有的结点数</li><li>同时还需要用一个res来存储层数</li><li>刚开始就要res初始化为0，同时将root根节点入队</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取上一层的元素个数</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="comment">// 将上一层元素出队同时将下一层元素入队</span></span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode n = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 高度+1</span></span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$，其中 N 为树的结点个数</li><li>空间复杂度：$O(N)$，其中 N 为树的结点个数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 394. 字符串解码</title>
    <link href="https://linzeliang.top/post/60772.html"/>
    <id>https://linzeliang.top/post/60772.html</id>
    <published>2021-05-13T14:44:53.000Z</published>
    <updated>2021-05-15T17:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>创建两个栈进行解题，一个用来存放数字，另一个用来临时存放子字符串</li><li>由于可能会在<code>[]</code>中还包含其他的<code>[]</code>，所以我们只要遇到<code>[</code>就先将其前面的字符串暂时入栈，稍后再进行计算</li><li>如果遇到<code>]</code> ，则将存放数字的栈和存放子字符串的栈分别出栈一个，然后进行字符串的拼接，然后再将该字符串作为答案的一部分进行下一轮迭代计算</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; times = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;String&gt; stringStack = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Character c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 如果为数字，则记录数字，数字有可能有十位或者百位</span></span><br><span class="line">            <span class="keyword">if</span> (isNum(c)) &#123;</span><br><span class="line">                count = count * <span class="number">10</span> + Integer.parseInt(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123; <span class="comment">// 如果为左中括号，则将数字和当前的res进栈</span></span><br><span class="line">                times.push(count);</span><br><span class="line">                stringStack.push(res.toString());</span><br><span class="line">                <span class="comment">// 注意还要将res置空，因为要开始下一轮的字符串统计，上一轮的字符串已经先暂存到栈中去了</span></span><br><span class="line">                res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="comment">// 次数也要置为0</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123; <span class="comment">// 如果为右中括号，则要开始计算本次统计的res，添加到上一个字符串的末尾</span></span><br><span class="line">                <span class="comment">// 获取次数</span></span><br><span class="line">                count = times.pop();</span><br><span class="line">                StringBuilder curString = <span class="keyword">new</span> StringBuilder(stringStack.pop());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    curString.append(res);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将拼接好后的字符串作为结果进行下一轮迭代</span></span><br><span class="line">                res = curString;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果都是字母的话仅进行平解字符串即可</span></span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为数字</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$，N为字符串的长度</li><li>空间复杂度：$O(N)$，N为字符串的长度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 1381. 设计一个支持增量操作的栈</title>
    <link href="https://linzeliang.top/post/44883.html"/>
    <id>https://linzeliang.top/post/44883.html</id>
    <published>2021-05-12T06:02:04.000Z</published>
    <updated>2021-05-15T17:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/">1381. 设计一个支持增量操作的栈</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用数组来存储栈的元素</li><li>通过一个point指针的移动完成栈的操作</li><li>进行增量操作时，需要判断操作的元素个数k是否大于当前栈中的元素容量</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        size = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        point = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (point &lt; size) &#123;</span><br><span class="line">            stack[point++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (point &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> stack[--point];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; i &lt; point; i++) &#123;</span><br><span class="line">            stack[i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(N)，N为栈的大小。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Win10安装MySQL5和MySQL8</title>
    <link href="https://linzeliang.top/post/34202.html"/>
    <id>https://linzeliang.top/post/34202.html</id>
    <published>2021-05-11T16:27:41.000Z</published>
    <updated>2021-05-11T16:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-下载数据库，配置环境变量"><a href="#1-下载数据库，配置环境变量" class="headerlink" title="1. 下载数据库，配置环境变量"></a>1. 下载数据库，配置环境变量</h2><p><strong>因为是安装两个MySQL数据库，端口号要不一样，MySQL默认端口号是3306，建议先配置非默认端口号，以免出现问题</strong></p><h3 id="1-1-官网下载5-7和8-0的压缩包"><a href="#1-1-官网下载5-7和8-0的压缩包" class="headerlink" title="1.1 官网下载5.7和8.0的压缩包"></a>1.1 <a href="https://downloads.mysql.com/archives/community/">官网</a>下载5.7和8.0的压缩包</h3><ul><li>我下载的是<code>5.7.23</code> 和<code>8.0.23</code></li></ul><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511221253559.png" alt="image-20210511221253559"></p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511221559191.png" alt="image-20210511221559191"></p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511221623829.png" alt="image-20210511221623829"></p><h3 id="1-2-解压到目录下"><a href="#1-2-解压到目录下" class="headerlink" title="1.2 解压到目录下"></a>1.2 解压到目录下</h3><ul><li><p>将压缩包解压到你要安装的目录，我这里是放到<code>D:\develop\MySQL</code>文件夹下</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511232856979.png" alt="image-20210511232856979"></p></li></ul><h3 id="1-3-配置系统变量"><a href="#1-3-配置系统变量" class="headerlink" title="1.3 配置系统变量"></a>1.3 配置系统变量</h3><p>在系统变量中添加<code>MYSQL5_HOME</code>和<code>MYSQL8_HOME</code>两个变量，变量值就是你的解压路径，然后在Path中将这两个的<code>bin</code>添加进去，完成后保存即可</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511232346352.png" alt="image-20210511232346352"></p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511232552106.png" alt="image-20210511232552106"></p><h2 id="2-安装MySQL8-0"><a href="#2-安装MySQL8-0" class="headerlink" title="2. 安装MySQL8.0"></a>2. 安装MySQL8.0</h2><h3 id="2-1-创建配置文件"><a href="#2-1-创建配置文件" class="headerlink" title="2.1 创建配置文件"></a>2.1 创建配置文件</h3><p>在根目录下创建<code>my.ini</code>的文件，文件的编码要是ANSI，然后再编辑配置文件保存</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span>  </span><br><span class="line"><span class="comment"># 设置 mysql 客户端默认字符集  </span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8 </span><br><span class="line"> </span><br><span class="line"><span class="section">[mysqld]</span>  </span><br><span class="line"><span class="comment">#设置端口  </span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3307</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 mysql 的安装目录  </span></span><br><span class="line"><span class="attr">basedir</span>=D:\develop\MySQL\mysql-<span class="number">8.0</span>.<span class="number">23</span>-winx64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 mysql 数据库的数据的存放目录  </span></span><br><span class="line"><span class="attr">datadir</span>=D:\develop\MySQL\mysql-<span class="number">8.0</span>.<span class="number">23</span>-winx64\data </span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许最大连接数  </span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许最大连接人数</span></span><br><span class="line"><span class="attr">max_user_connections</span>=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为 8 比特编码的 latin1 字符集  </span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="comment">#default-storage-engine=MyISAM</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接时间</span></span><br><span class="line"><span class="attr">wait_timeout</span>=<span class="number">31536000</span></span><br><span class="line"><span class="attr">interactive_timeout</span>=<span class="number">31536000</span></span><br></pre></td></tr></table></figure><h3 id="2-2-初始化MySQL"><a href="#2-2-初始化MySQL" class="headerlink" title="2.2 初始化MySQL"></a>2.2 初始化MySQL</h3><p>确保根目录下没有data文件夹，如果有，就先删除，然后cmd进入到bin目录下</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511233917085.png" alt="image-20210511233917085"></p><p>执行<code>mysqld --initialize</code></p><ul><li>如果执行<code>mysqld --initialize-insecure</code>，则创建的root默认没有密码</li></ul><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511233955289.png" alt="image-20210511233955289"></p><p>完成初始化，自动在根目录下创建一个data文件夹</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511234017435.png" alt="image-20210511234017435"></p><p>此时，mysql的root用户密码默认是空的，如果你没有加上<code>-insecure</code>，则会分配随机密码，密码在data目录下的<code>xxx.err</code>文件里：</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511234228371.png" alt="image-20210511234228371"></p><p>由于我的默认空密码，所以没有显示，否则会在这末尾有显示</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511234316425.png" alt="image-20210511234316425"></p><h3 id="2-3-安装MySQL服务"><a href="#2-3-安装MySQL服务" class="headerlink" title="2.3 安装MySQL服务"></a>2.3 安装MySQL服务</h3><p>在命令行中输入<code>mysqld --install MYSQL80</code><strong>（MYSQL80是服务名称，可以自定义，必须要加上，因为默认的是MYSQL，如果不加，两个数据库就会冲突了）</strong></p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511234836288.png" alt="image-20210511234836288"></p><h3 id="2-4-开启MySQL服务"><a href="#2-4-开启MySQL服务" class="headerlink" title="2.4 开启MySQL服务"></a>2.4 开启MySQL服务</h3><p>在命令行中输入<code>net start MYSQL80</code>开启MySQL8.0服务</p><p><strong>如果输入命令后提示无法开启，如图：</strong></p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511235001042.png" alt="image-20210511235001042"></p><p>应该是服务配置有问题，打开系统的服务配置，找到MYSQL80</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511235102129.png" alt="image-20210511235102129"></p><p>右击查看属性，很明显，这路径错了（应该是以前安装过MySQL，没删除干净，导致缓存）</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511235235092.png" alt="image-20210511235235092"></p><p>不过没关系，我们可以手动修改</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511235315742.png" alt="image-20210511235315742"></p><p>成功启动！</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511235443037.png" alt="image-20210511235443037"></p><h3 id="2-5-修改初始化密码"><a href="#2-5-修改初始化密码" class="headerlink" title="2.5 修改初始化密码"></a>2.5 修改初始化密码</h3><p>命令行输入<code>mysql -u root -P 3307 -p</code>（-P是代表端口号，-p代表密码，-u代表用户）进入MySQL，由于我没有密码，所以直接回车进入，如果有密码，将生成的密码填入即可</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210511235640737.png" alt="image-20210511235640737"></p><p>然后修改密码，输入<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code></p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210512000447763.png" alt="image-20210512000447763"></p><p>最后刷新权限，输入<code>flush privileges</code></p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210512000503612.png" alt="image-20210512000503612"></p><p>到此，MySQL8就安装成功了</p><h2 id="3-安装MySQL5-7"><a href="#3-安装MySQL5-7" class="headerlink" title="3. 安装MySQL5.7"></a>3. 安装MySQL5.7</h2><p>同理，和安装MySQL8.0基本是一样的，只是有一些细微差别</p><h3 id="3-1-端口号要不同"><a href="#3-1-端口号要不同" class="headerlink" title="3.1 端口号要不同"></a>3.1 端口号要不同</h3><p>MySQL5.7对于我来说比较常用，所以我将它设置为3306默认端口号，<strong>同时路径也要修改</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[mysql]  </span><br><span class="line"># 设置 mysql 客户端默认字符集  </span><br><span class="line">default-character-set=utf8 </span><br><span class="line"> </span><br><span class="line">[mysqld]  </span><br><span class="line">#设置端口  </span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line"># 设置 mysql 的安装目录  </span><br><span class="line">basedir=D:\develop\MySQL\mysql-5.7.23-winx64</span><br><span class="line"></span><br><span class="line"># 设置 mysql 数据库的数据的存放目录  </span><br><span class="line">datadir=D:\develop\MySQL\mysql-5.7.23-winx64\data </span><br><span class="line"></span><br><span class="line"># 允许最大连接数  </span><br><span class="line">max_connections=10000</span><br><span class="line"></span><br><span class="line"># 允许最大连接人数</span><br><span class="line">max_user_connections=1000</span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为 8 比特编码的 latin1 字符集  </span><br><span class="line">character-set-server=utf8  </span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">#default-storage-engine=MyISAM</span><br><span class="line">default-storage-engine=InnoDB</span><br><span class="line"></span><br><span class="line"># 连接时间</span><br><span class="line">wait_timeout=31536000</span><br><span class="line">interactive_timeout=31536000</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="https://linzeliang.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://linzeliang.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 821. 字符的最短距离</title>
    <link href="https://linzeliang.top/post/8733.html"/>
    <id>https://linzeliang.top/post/8733.html</id>
    <published>2021-05-11T15:39:32.000Z</published>
    <updated>2021-05-17T00:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">821. 字符的最短距离</a></p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><ul><li><p>使用一个res数组，而且要初始化为Integer.MAX_VALUE</p></li><li><p>从左到右遍历字符串，直到遇到我们的目标字符时候停下来</p></li><li><p>以目标字符为中心，pre和next双指针向两边移动，并且给数组赋值，从1开始递增</p></li><li><p>如果指针再移动过程中遇到当前的值大于等于左边/右边的值，那么就结束该指针的移动</p><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/2067154-20201102004404706-1773904769.png" alt=""></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = S.length();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">// 填充最大值</span></span><br><span class="line">        Arrays.fill(res, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//每次遇到e时候，就进行pre和next的移动</span></span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == C) &#123;</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> pre = i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> next = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 赋值的条件是t要小于等于前一个/后一个元素的值</span></span><br><span class="line">                <span class="comment">// 进行左移动赋值</span></span><br><span class="line">                <span class="keyword">while</span> (pre &gt;= <span class="number">0</span> &amp;&amp; t &lt; res[pre]) &#123;</span><br><span class="line">                    res[pre--] = t++;</span><br><span class="line">                &#125;</span><br><span class="line">                t = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 进行右移动赋值</span></span><br><span class="line">                <span class="keyword">while</span> (next &lt; len &amp;&amp; t &lt; res[next]) &#123;</span><br><span class="line">                    res[next++] = t++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N^2)$，其中 N 为字符串长度。</li><li>空间复杂度：$O(N)$，其中 N 为res数组长度</li></ul><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><ul><li>正向遍历一次，反向遍历一次</li><li>用<code>pre</code>标记出现目标字符的位置，利用<code>i</code>的自增，同时给数组赋值</li><li>正向遍历是给目标字符之后到下一个目标字符之前进行赋值，反向遍历则相反</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String s, <span class="keyword">char</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">// 必须要除以2，因为Integer.MIN_VALUE已经是最小值了，又因为i&gt;=0，所以 i-pre 会超过整型最大值</span></span><br><span class="line">        <span class="keyword">int</span> pre = Integer.MIN_VALUE / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == c) &#123;</span><br><span class="line">                pre = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = i - pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向遍历</span></span><br><span class="line">        pre = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == c) &#123;</span><br><span class="line">                pre = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = Math.min(res[i], pre - i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$，其中 N 为字符串长度。</li><li>空间复杂度：$O(N)$，其中 N 为res数组长度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣 - 989. 数组形式的整数加法</title>
    <link href="https://linzeliang.top/post/7278.html"/>
    <id>https://linzeliang.top/post/7278.html</id>
    <published>2021-05-10T07:16:19.000Z</published>
    <updated>2021-05-15T17:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/">989. 数组形式的整数加法</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>从最低位开始加，满10用carry进1，最后还要判断最终有没有进1位</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = num.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span> || k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = n &lt; <span class="number">0</span> ? <span class="number">0</span> : num[n];</span><br><span class="line">            <span class="keyword">int</span> b = k % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = (a + b + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (a+ b + carry) / <span class="number">10</span>;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            n--;</span><br><span class="line">            k /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题目录</title>
    <link href="https://linzeliang.top/post/344.html"/>
    <id>https://linzeliang.top/post/344.html</id>
    <published>2021-05-10T02:36:22.000Z</published>
    <updated>2021-06-08T13:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一周（16）"><a href="#第一周（16）" class="headerlink" title="第一周（16）"></a>第一周（16）</h2><h3 id="easy-12"><a href="#easy-12" class="headerlink" title="easy - 12"></a>easy - 12</h3><ol><li><a href="https://linzeliang.top/2021/05/13/leetcode-maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>（题解）</li><li><a href="https://linzeliang.top/2021/05/14/leetcode-implement-queue-using-stacks/">232. 用栈实现队列</a>（题解）</li><li><a href="https://linzeliang.top/2021/05/11/leetcode-shortest-distance-to-a-character/">821. 字符的最短距离</a>（题解）</li><li><a href="https://www.cnblogs.com/linzeliang1222/p/14751487.html">989. 数组形式的整数加法</a>（题解）</li><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></li><li><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501 二叉搜索树中的众数</a></li><li><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530 二叉搜索树的最小绝对差</a></li><li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543 二叉树的直径</a></li><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559 N 叉树的最大深度</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></li><li><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></li></ol><h3 id="medium-3"><a href="#medium-3" class="headerlink" title="medium - 3"></a>medium - 3</h3><ol><li><a href="https://linzeliang.top/2021/05/16/leetcode-rotate-list/">61. 旋转链表</a>（题解）</li><li><a href="https://linzeliang.top/2021/05/13/leetcode-decode-string/">394. 字符串解码</a>（题解）</li><li><a href="https://linzeliang.top/2021/05/12/leetcode-design-a-stack-with-increment-operation/">1381. 设计一个支持增量操作的栈</a>（题解）</li></ol><h3 id="hard-1"><a href="#hard-1" class="headerlink" title="hard - 1"></a>hard - 1</h3><ol><li><a href="https://linzeliang.top/2021/05/15/leetcode-max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a>（题解）</li></ol><hr><h2 id="第二周（5）"><a href="#第二周（5）" class="headerlink" title="第二周（5）"></a>第二周（5）</h2><h3 id="easy-1"><a href="#easy-1" class="headerlink" title="easy - 1"></a>easy - 1</h3><ol><li><a href="https://linzeliang.top/2021/05/19/leetcode-intersection-of-two-linked-lists/">160. 相交链表</a>（题解）</li></ol><h3 id="medium-4"><a href="#medium-4" class="headerlink" title="medium - 4"></a>medium - 4</h3><ol><li><a href="https://linzeliang.top/2021/05/17/leetcode-swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>（题解）</li><li><a href="https://linzeliang.top/2021/05/18/leetcode-convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>（题解）</li><li><a href="https://linzeliang.top/2021/05/20/leetcode-linked-list-cycle-ii/">142. 环形链表 II</a>（题解）</li><li><a href="https://linzeliang.top/2021/05/17/leetcode-daily-temperatures/">739. 每日温度</a>（题解）</li></ol><h3 id="hard-0"><a href="#hard-0" class="headerlink" title="hard - 0"></a>hard - 0</h3><hr><h2 id="第三周（2）"><a href="#第三周（2）" class="headerlink" title="第三周（2）"></a>第三周（2）</h2><h3 id="easy-2"><a href="#easy-2" class="headerlink" title="easy - 2"></a>easy - 2</h3><ol><li><a href="https://linzeliang.top/2021/05/31/leetcode-binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>（题解）</li><li><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></li></ol><h3 id="medium-0"><a href="#medium-0" class="headerlink" title="medium - 0"></a>medium - 0</h3><ol><li></li></ol><h3 id="hard-0-1"><a href="#hard-0-1" class="headerlink" title="hard - 0"></a>hard - 0</h3><ol><li></li></ol><hr><h2 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h2><h3 id="easy-4"><a href="#easy-4" class="headerlink" title="easy - 4"></a>easy - 4</h3><ol><li><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></li><li><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></li><li><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></li><li><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></li></ol><h3 id="medium-0-1"><a href="#medium-0-1" class="headerlink" title="medium - 0"></a>medium - 0</h3><ol><li></li></ol><h3 id="hard-0-2"><a href="#hard-0-2" class="headerlink" title="hard - 0"></a>hard - 0</h3><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://linzeliang.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://linzeliang.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC笔记（五）</title>
    <link href="https://linzeliang.top/post/449.html"/>
    <id>https://linzeliang.top/post/449.html</id>
    <published>2021-04-29T17:13:24.000Z</published>
    <updated>2021-04-29T17:13:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-拦截器"><a href="#1-拦截器" class="headerlink" title="1. 拦截器"></a>1. 拦截器</h2><h3 id="1-1-拦截器和过滤器"><a href="#1-1-拦截器和过滤器" class="headerlink" title="1.1 拦截器和过滤器"></a>1.1 拦截器和过滤器</h3><p>SpringMVC的处理器拦截器类似于Servlet开发过程中的过滤器Filter，用于对处理器进行预处理和后处理。我们可以自定义一些拦截器来实现特定的功能</p><p>过滤器和拦截器的区别：<strong>拦截器是AOP思想的具体应用</strong></p><p>过滤器：</p><ul><li>Servlet规范中的一部分，任何JavaWeb工程都可以使用</li><li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li></ul><p>拦截器：</p><ul><li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li><li>拦截器指挥拦截访问的控制器方法，如果访问的是jsp/html/css/img/js是不会进行拦截的</li></ul><h3 id="1-2-自定义拦截器"><a href="#1-2-自定义拦截器" class="headerlink" title="1.2 自定义拦截器"></a>1.2 自定义拦截器</h3><ol><li><p>首先编写一个类，实现HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在业务处理器处理请求之前被调用</span></span><br><span class="line"><span class="comment">     * 如果返回false</span></span><br><span class="line"><span class="comment">     *     从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链</span></span><br><span class="line"><span class="comment">     * 如果返回true</span></span><br><span class="line"><span class="comment">     *    执行下一个拦截器,直到所有的拦截器都执行完毕</span></span><br><span class="line"><span class="comment">     *    再执行被拦截的Controller</span></span><br><span class="line"><span class="comment">     *    然后进入拦截器链,</span></span><br><span class="line"><span class="comment">     *    从最后一个拦截器往回执行所有的postHandle()</span></span><br><span class="line"><span class="comment">     *    接着再从最后一个拦截器往回执行所有的afterCompletion()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------处理前------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在业务处理器处理请求执行完成后,生成视图之前执行的动作</span></span><br><span class="line"><span class="comment">     * 可在modelAndView中加入数据，比如当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------处理后------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------清理------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在springmvc配置文件中配置拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--关于拦截器的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--/** 包括路径及其子路径--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--/admin/** 拦截的是/admin/下的所有--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--bean配置的就是拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-文件上传下载"><a href="#2-文件上传下载" class="headerlink" title="2. 文件上传下载"></a>2. 文件上传下载</h2><h3 id="2-1-上传"><a href="#2-1-上传" class="headerlink" title="2.1 上传"></a>2.1 上传</h3><ol><li><p>首先，表单中的<code>enctype</code>属性要设置为<code>multipart/form-data</code>，只有用这种方式，才会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数种，不会对字符进行编码，其他的一些格式：</p><ul><li>application/x-www=form-urlencoded：默认方式，只处理表单中的value属性值，采用这种编码方式的表单会将表单域中的值处理成url编码方式</li><li>text/plain：处理个空格转换为’<code>+</code>‘外，对其他字符都不做编码处理</li></ul></li><li><p>然后导入相关jar包，commons-fileupload</p></li><li><p><strong>配置bean：</strong>multipartResolver</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传配置，id必须为multipartResolver--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CommonsMultipartFile 的 常用方法：</p><ul><li><strong>String getOriginalFilename()：</strong>获取上传文件的原名</li><li><strong>InputStream getInputStream()：</strong>获取文件流</li><li><strong>void transferTo(File dest)：</strong>将上传文件保存到一个目录文件中</li></ul></li><li><p>编写Controller控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象</span></span><br><span class="line">    <span class="comment">//批量上传CommonsMultipartFile则为数组即可</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file , HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取文件名 : file.getOriginalFilename();</span></span><br><span class="line">        String uploadFileName = file.getOriginalFilename();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果文件名为空，直接回到首页！</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(uploadFileName))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件名 : &quot;</span>+uploadFileName);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//上传路径保存设置</span></span><br><span class="line">        String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        <span class="comment">//如果路径不存在，创建一个</span></span><br><span class="line">        File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">            realPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件保存地址：&quot;</span>+realPath);</span><br><span class="line"> </span><br><span class="line">        InputStream is = file.getInputStream(); <span class="comment">//文件输入流</span></span><br><span class="line">        OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(realPath,uploadFileName)); <span class="comment">//文件输出流</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//读取写出</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>或者采用<code>file.Transto</code>来上传文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String  <span class="title">fileUpload2</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上传路径保存设置</span></span><br><span class="line">    String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">    <span class="comment">//上传文件地址</span></span><br><span class="line">    File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">        realPath.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span></span><br><span class="line">    file.transferTo(<span class="keyword">new</span> File(realPath +<span class="string">&quot;/&quot;</span>+ file.getOriginalFilename()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-下载"><a href="#2-2-下载" class="headerlink" title="2.2 下载"></a>2.2 下载</h3><p><strong>文件下载步骤：</strong></p><ol><li>设置response响应头</li><li>读取文件 -&gt; InputStream</li><li>写出文件 -&gt; OutputStream</li><li>执行操作</li><li>关闭流</li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/download&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">downloads</span><span class="params">(HttpServletResponse response ,HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//要下载的图片地址</span></span><br><span class="line">    String  path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">    String  fileName = <span class="string">&quot;基础语法.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、设置response 响应头</span></span><br><span class="line">    response.reset(); <span class="comment">//设置页面不缓存,清空buffer</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//字符编码</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;multipart/form-data&quot;</span>); <span class="comment">//二进制传输数据</span></span><br><span class="line">    <span class="comment">//设置响应头</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;attachment;fileName=&quot;</span>+URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">    <span class="comment">//2、 读取文件--输入流</span></span><br><span class="line">    InputStream input=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    <span class="comment">//3、 写出文件--输出流</span></span><br><span class="line">    OutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buff =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//4、执行 写出操作</span></span><br><span class="line">    <span class="keyword">while</span>((index= input.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">        out.write(buff, <span class="number">0</span>, index);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="框架学习" scheme="https://linzeliang.top/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringMVC" scheme="https://linzeliang.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC笔记（四）</title>
    <link href="https://linzeliang.top/post/50047.html"/>
    <id>https://linzeliang.top/post/50047.html</id>
    <published>2021-04-28T15:33:29.000Z</published>
    <updated>2021-04-29T02:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-结果跳转方式"><a href="#1-结果跳转方式" class="headerlink" title="1. 结果跳转方式"></a>1. 结果跳转方式</h2><h3 id="1-1-ModelAndView"><a href="#1-1-ModelAndView" class="headerlink" title="1.1 ModelAndView"></a>1.1 ModelAndView</h3><p>设置ModelAndView对象，根据view的名称和视图解析器跳转到指定的页面（视图解析器前缀 + viewName + 视图解析器后缀）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的Controller控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">        mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-ServletAPI"><a href="#1-2-ServletAPI" class="headerlink" title="1.2 ServletAPI"></a>1.2 ServletAPI</h3><p>通过设置ServletAPI，不需要视图解析器</p><ol><li><p>通过HttpServletResponse进行输出</p></li><li><p>通过HttpServletResponse进行重定向</p></li><li><p>通过HttpServletResponse实现转发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultGo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/result/t1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        rsp.getWriter().println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/result/t2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        rsp.sendRedirect(<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/result/t3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//转发</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;/result/t3&quot;</span>);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>).forward(req,rsp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-SpringMVC"><a href="#1-3-SpringMVC" class="headerlink" title="1.3 SpringMVC"></a>1.3 SpringMVC</h3><p>通过SpringMVC来实现转发和重定向，视图解析器可以使用也可以不使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/rsm2/t1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//转发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/rsm2/t2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">        <span class="comment">//hello.do为另一个请求/</span></span><br><span class="line">        <span class="comment">//return &quot;redirect:hello.do&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2. 数据处理"></a>2. 数据处理</h2><h3 id="2-1-处理提交数据"><a href="#2-1-处理提交数据" class="headerlink" title="2.1 处理提交数据"></a>2.1 处理提交数据</h3><ol><li><p>提交时候的参数名和处理方法的参数名一致，则会自动匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提交时候的参数名和处理方法的参数名不一致，需要在方法的参数列表中使用<code>@RequestParam</code>注解进行手动绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RequestParam(&quot;username&quot;) : username 提交的域的名称 .</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提交的是一个对象</p><ul><li>如果提交的是一个对象，则参数直接使用对象即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-数据显示到前端"><a href="#3-数据显示到前端" class="headerlink" title="3. 数据显示到前端"></a>3. 数据显示到前端</h2><h3 id="3-1-通过ModelAndView"><a href="#3-1-通过ModelAndView" class="headerlink" title="3.1 通过ModelAndView"></a>3.1 通过ModelAndView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 返回一个模型视图对象</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">        mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-通过ModelMap"><a href="#3-2-通过ModelMap" class="headerlink" title="3.2 通过ModelMap"></a>3.2 通过ModelMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, ModelMap model)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">    <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-通过Model"><a href="#3-3-通过Model" class="headerlink" title="3.3 通过Model"></a>3.3 通过Model</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ct2/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">    <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-三种方式对比"><a href="#3-4-三种方式对比" class="headerlink" title="3.4 三种方式对比"></a>3.4 三种方式对比</h3><ul><li>Model 只有寥寥几个方法只适合用于储存数据，简化了Model对象的操作和理解</li><li>ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性</li><li>ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转</li></ul><h2 id="4-乱码问题"><a href="#4-乱码问题" class="headerlink" title="4. 乱码问题"></a>4. 乱码问题</h2><p>我们可以通过修改配置文件web.xml中的过滤器，spring自带<code>CharacterEncodingFilter</code>过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用<strong>自定义的过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.linzeliang.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//处理response的字符编码</span></span><br><span class="line">        HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">        myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 对request包装增强</span></span><br><span class="line">        HttpServletRequest myrequest = <span class="keyword">new</span> MyRequest(httpServletRequest);</span><br><span class="line">        chain.doFilter(myrequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="comment">//是否编码的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasEncode;</span><br><span class="line">    <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获得请求方式</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// post请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理post乱码</span></span><br><span class="line">                request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// get请求</span></span><br><span class="line">            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">                <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                    String[] values = parameterMap.get(parameterName);</span><br><span class="line">                    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 处理get乱码</span></span><br><span class="line">                                values[i] = <span class="keyword">new</span> String(values[i]</span><br><span class="line">                                                       .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hasEncode = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取一个值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取所有值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="框架学习" scheme="https://linzeliang.top/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringMVC" scheme="https://linzeliang.top/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
