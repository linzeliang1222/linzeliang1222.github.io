<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap源码剖析</title>
    <url>/2021/09/24/hashmap-source-code-analysis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-HashMap继承结构"><a href="#1-HashMap继承结构" class="headerlink" title="1. HashMap继承结构"></a>1. HashMap继承结构</h3><p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632487670.png" alt="image-20210924204750139"></p>
<h3 id="2-HashMap底层数据结构"><a href="#2-HashMap底层数据结构" class="headerlink" title="2. HashMap底层数据结构"></a>2. HashMap底层数据结构</h3><p>在1.7及其之前，<code>HashMap</code>底层是使用 数组 + 链表实现的，在1.8及其之后，使用了 数组 + 链表/红黑树 实现。</p>
<p>来看下1.7的储存结构图：</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632485062.png" alt="image-20210924200421961"></p>
<p>其中链表使用内部类Node来实现的：</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632487826.png" alt="image-20210924205026504"></p>
<p><strong>数组+链表（散列表）</strong> 其实就是用于解决哈希冲突使用的一个<code>拉链法</code>方法。<strong>在数据结构中，我们处理hash冲突常使用的方法有：开发定址法、再哈希法、链地址法、建立公共溢出区。而HashMap中处理hash冲突的方法就是链地址法。</strong></p>
<p>但是这样子的话，如果使用了很久，HashMap存储的元素越来越多，那么链表就会变的很长，那么<strong>性能就会下降很多</strong>（因为链表不适合查找元素，每次查找元素都要从头开始遍历）。</p>
<p>于是在1.8的时候进行了改进，使用到了<strong>红黑树</strong>（红黑树是一个自平衡的二叉查找树，查找效率是非常高，时间复杂度仅为O(logN)）。</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632486698.png" alt="image-20210924203138870"></p>
<p>在HashMap中，链表转化成红黑树的条件是当<strong>链表长度大于8</strong>且<strong>数组(桶)的个数要大雨等于64个</strong>时，才可以将链表转化成红黑树，它们在源码中的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 转化成红黑树的最小的桶容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 桶上的元素的数量</span></span><br></pre></td></tr></table></figure>
<p>treeifyBin中的片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 意思是只要桶的个数小于64个，那么即使桶中的元素个数超过了8个，那么就进行resize扩容，而不是转化成红黑树</span></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)  </span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure>
<p>putVal中的片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// -1 for 1st 可以理解为元素下表从-1开始的，所以可以看作binCount &gt;= 9</span></span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">        treeifyBin(tab, hash);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-HashMap的属性"><a href="#3-HashMap的属性" class="headerlink" title="3. HashMap的属性"></a>3. HashMap的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量，左移位4位相当于：1*2*2*2*2=16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大的容量：2的30次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认装载因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当一个元素被添加到至少有8个节点的桶中，桶中的链表将会被转化成红黑树，即转化成红黑树条件是大于8个</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树退化成链表的条件：小于等于6时退化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转化成红黑树的最小的桶的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>成员属性有如下：</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632487601.png" alt="image-20210924204641256"></p>
<h3 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h3><p>一共有4个构造方法：</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1632490501.png" alt="image-20210924213501347"></p>
<p>其中，核心的构造方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证初始容量大于等于0，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="comment">// 保证初始容量不大于最大容量，超过了就讲初始容量设置为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 保证装载因子大于0</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="comment">// 初始化装载因子为0.75</span></span><br><span class="line">    <span class="comment">// 当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// threshold这个成员变量是阈值，决定了是否要将散列表再散列，它的值应该是：capacity * load factor</span></span><br><span class="line">    <span class="comment">// 但是这里的threshold并不是真正的初始化阈值，正在的初始化阈值时在resize的时候进行初始化（而此时的threshold并不是没有用，而是待会在初始化容量时候要用的初始值）</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化阈值容量的时候，调用了<code>tableSizeFor</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法返回大于输入数字的最近的2的整数次幂的数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-put方法"><a href="#5-put方法" class="headerlink" title="5. put方法"></a>5. put方法</h3><p>put方法其实是调用了putVal方法的，调用方法的同时把计算好的key的哈希值传入，putVal方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put的<strong>过程如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; <span class="comment">// tab表示的是哈希数组</span></span><br><span class="line">Node&lt;K,V&gt; p; <span class="comment">// p表示的是数组的第一个节点</span></span><br><span class="line">Node&lt;K,V&gt; e; <span class="comment">// e表示该key是否已经存在，为null表示不存在</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>put方法接收传入key与value：<code>put(K key, V value)</code></p>
</li>
<li><p>计算出key的哈希值，这里计算的哈希值方法是key的hashcode与hashcode的高16位进行异或运算得到的结果</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将计算得到的哈希值、key、value传给putVal方法</p>
</li>
<li><p>在putVal方法中，先判断哈希数组是否为空，如果为空的话就resize初始化tab，创建新的数组</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断tab是否为空</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果存在哈希表，则计算key对应的索引位置：<code>p = tab[i = (n - 1) &amp; hash</code>，使用<code>length-1</code>与<code>hash</code>进行逻辑与运算（因为在做<code>&amp;</code>运算的时候，<strong>仅仅是后4位有效</strong>，那么如果key的哈希值<strong>低位变化不大，高位变化大</strong>，那么在计算的时候发生哈希冲突的可能性也增大许多，所以上面在计算哈希的时候将hash与hash的高16为进行异或运算得到结果作为哈希值，增加了<strong>随机性</strong>），如果改索引位置还没有节点，那么就直接插入到该位置即可！</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果该桶上有元素的话，就根据该桶的结构是红黑树还是链表进行插入，然后返回结果赋值给<code>e</code>：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    <span class="comment">// 是树形结构按照树形结构插入</span></span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 按照链表结构插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 判断是否要转化成红黑树结构</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果e是为<code>null</code>，就说明该key不存在，直接插入，如果不为<code>null</code>，说明key已经存在，直接将覆盖原来的value，并返回</p>
</li>
<li><p>插入成功之后，还要判断一下实际存在的键值对的数量<code>size</code>是否大于阈值<code>threshold</code>，如果大于那么就扩容</p>
</li>
</ol>
<h3 id="6-扩容"><a href="#6-扩容" class="headerlink" title="6. 扩容"></a>6. 扩容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>先判断原来的容量是否大于0</p>
</li>
<li><p>如果大于0的话且大于等于最大容量，就将阈值设置为Integer.MAX_VALUE，然后啥也不干</p>
<p> 如果大于0的话且小于于最大容量就将旧的容量扩容为原来的两倍，同时也将旧的阈值扩大为原来的两倍</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果初始容量未制定或者小于等于0（就是HashMap构造方法的那种情况，只初始化了threshold阈值），那么就将阈值作为初始化容量（此时阈值是2的整数次幂，HashMap的容量要为2的整数次幂）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>剩下的情况就是初始容量没有设定，阈值也没有设定，那么容量就用默认的<code>DEFAULT_INITIAL_CAPACITY</code>，阈值则为：<code>(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果新容量的阈值为设定，那么就设定下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新当前容量的阈值</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threshold = newThr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后就是将旧的数据复制到新数组里面，有两种情况：</p>
<ol>
<li>扩容后，若hash值新增参与运算的位=0，那么元素在扩容后的位置=原始位置</li>
<li><p>扩容后，若hash值新增参与运算的位=1，那么元素在扩容后的位置=原始位置+扩容后的旧位置</p>
<p>扩容后长度为原hash表的2倍，于是把hash表分为两半，分为低位和高位，如果能把原链表的键值对， 一半放在低位，一半放在高位，而且是通过<code>e.hash &amp; oldCap == 0</code>来判断。因此有50%的概率放在新hash表低位，50%的概率放在新hash表高位。</p>
</li>
</ol>
</li>
</ol>
<h3 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7. get方法"></a>7. get方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法的实现就是计算key的hash值，然后通过getNode获取对应的value</p>
<h3 id="8-remove方法"><a href="#8-remove方法" class="headerlink" title="8. remove方法"></a>8. remove方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove方法也是通过计算key的hash，调用removeNode来删除元素的</p>
<h3 id="9-HashMap的一些特性"><a href="#9-HashMap的一些特性" class="headerlink" title="9. HashMap的一些特性"></a>9. HashMap的一些特性</h3><ul>
<li>允许key和value为null</li>
<li>除了允许为努力了和同步，其他的和HashTable一样</li>
<li>不保证有序</li>
<li>初始容量太高或者太低对便利都不太好</li>
<li>当哈希表容量超过初始容量<em>装载因子时，哈希表会进行再散裂，桶数量\</em>2</li>
<li>不同步，想要同步可以使用Collections工具类实现<code>Map m = Collections.synchronizedMap(new HashMap(...));</code></li>
<li>装载因子默认是0.75，设置高虽然会减少空间，但是遍历的开销会增加。因此在设置初始容量时，应该考虑好装载因子和容量的大小，如果设置的好，就不用再散裂了</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Srping笔记（五）</title>
    <url>/2021/03/27/spring-note-5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、事务（概念）"><a href="#一、事务（概念）" class="headerlink" title="一、事务（概念）"></a>一、事务（概念）</h2><h3 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h3><ol>
<li>事务是数据库的最基本单元，逻辑上的一组操作，要么都成功，如果有一个失败，那么所有的操作都失败</li>
<li>典型场景：<ul>
<li>lucy转账100元给mary</li>
<li>lucy少100元，mary多100元</li>
</ul>
</li>
</ol>
<h3 id="2-事务的四个特性（ACID）"><a href="#2-事务的四个特性（ACID）" class="headerlink" title="2. 事务的四个特性（ACID）"></a>2. 事务的四个特性（ACID）</h3><ol>
<li>原子性（<strong>A</strong>tomicity）</li>
<li>一致性（<strong>C</strong>onsistency）</li>
<li>隔离性（<strong>I</strong>solation）</li>
<li>持久性（<strong>D</strong>urability）</li>
</ol>
<h2 id="二、事务操作"><a href="#二、事务操作" class="headerlink" title="二、事务操作"></a>二、事务操作</h2><h3 id="1-Spring事务管理介绍"><a href="#1-Spring事务管理介绍" class="headerlink" title="1. Spring事务管理介绍"></a>1. Spring事务管理介绍</h3><ol>
<li><p>事务添加到JavaEE三层结构里面Service层（业务逻辑层）</p>
</li>
<li><p>在Spring进行事务管理操作</p>
<ol>
<li>编程式事务管理：就是在代码中编写代码，手动开启事务</li>
<li>声明式事务管理：面向切面配置事务，开启事务</li>
</ol>
</li>
<li><p>声明式事务管理</p>
<ol>
<li>基于注解方式（使用）</li>
<li>基于xml配置文件方式</li>
</ol>
</li>
<li><p>在Spring进行声明式事务管理，底层使用AOP原理</p>
</li>
<li><p>Spring事务管理API</p>
<ul>
<li><p>提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210330072804983.png" alt=""></p>
</li>
</ul>
</li>
</ol>
<h3 id="2-注解声明式事务管理"><a href="#2-注解声明式事务管理" class="headerlink" title="2. 注解声明式事务管理"></a>2. 注解声明式事务管理</h3><ol>
<li><p>在Spring配置文件<strong>配置事务管理器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Spring配置文件，<strong>开启事务注解</strong></p>
<ol>
<li><p>在spring配置文件引入名称空间tx</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启事务注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启事务注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在service类上面（或者service类里面的方法上面）添加事务注解</p>
<ol>
<li><p>@Transaction，这个注解添加到类上面，也可以添加方法上面</p>
</li>
<li><p>如果把这个注解添加到类上面，这个类里面多有的方法都添加事务</p>
</li>
<li><p>如果把这个注解添加到方法上面，那么只是为这个方法添加事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="3-声明式事务管理参数配置"><a href="#3-声明式事务管理参数配置" class="headerlink" title="3. 声明式事务管理参数配置"></a>3. 声明式事务管理参数配置</h3><ol>
<li><p>在service类声明添加注解@Transaction，这个注解里面可以配置事务相关参数</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210330075209818.png" alt=""></p>
</li>
<li><p><strong>propagation：事务传播行为</strong></p>
<ol>
<li><p><strong>事务传播行为：</strong>多事务方法直接进行调用，这个过程中事务是如何进行管理的</p>
</li>
<li><p>事务方法：对数据库表的书籍进行变化的操作</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210330075518061.png" alt=""></p>
</li>
<li><p>Spring框架事务传播行为有<strong>7种</strong>，重点掌握<code>REQUIRED</code>和<code>REQUIRES_NEW</code></p>
<ul>
<li><p>REQUIRED：如果add方法本身有事务，调用update方法后，update使用当前add方法里面的事务；如果add方法本身没有事务，那么调用update方法之后，创建新事务</p>
</li>
<li><p>REQUIRES_NEW：使用add方法调用update方法，无论add方法是否有事务，update都要创建新事务，如果add方法的事务正在运行，那么update方法的事务要先挂起</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210330075752730.png" alt=""></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>isolation：事务隔离级别</p>
<ol>
<li>事务有特性成为隔离性，多事务之间操作不会产生影响。如果不考虑隔离性则会产生很多问题</li>
<li>有三个问题：脏读、不可重复读、幻读</li>
<li><strong>脏读</strong>：在一个事务种读取到另一个未提交事务的数据</li>
</ol>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210330080558276.png" alt=""></p>
<ol>
<li><strong>不可重复读：</strong>在一个事务中，两次查询到的结果不一致（针对update操作）</li>
</ol>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210330080816342.png" alt=""></p>
<ol>
<li><p><strong>幻读：</strong>在一个事务种，两次查询到的结果不一致（针对insert操作）</p>
</li>
<li><p><strong>如何解决这些问题？</strong></p>
<ul>
<li><p>通过设置事务隔离级别，解决读问题</p>
</li>
<li><p>SQL标准的事务隔离级别包括：读未提交、读提交、可重复读（MySQL中默认）、串行化</p>
<ul>
<li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到</li>
<li>读已提交：一个事务提交之后，它做的变更才能被其他事务看到</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的</li>
<li>串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出像读写锁冲突时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li>
</ul>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210330081135733.png" alt=""></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>timeout：超时时间</p>
<ul>
<li>事务需要在一定的时间内进行提交，如果不提交则进行回滚</li>
<li>默认值是-1，设置时间以秒单位进行计算</li>
</ul>
</li>
<li><p>readOnly：是否只读</p>
<ul>
<li>读：查询操作    写：添加、修改、删除</li>
<li>readOnly默认值是false，表示可以读，也可以写</li>
<li>readOnly设置成true，只能进行读操作，即查询</li>
</ul>
</li>
<li><p>rollbaclFor：回滚</p>
<ul>
<li>设置出现哪些异常进行事务回滚</li>
</ul>
</li>
<li><p>noRollbackFor：不回滚</p>
<ul>
<li>设置出现哪些异常不进行事务回滚</li>
</ul>
</li>
</ol>
<h3 id="4-XML声明式事务管理"><a href="#4-XML声明式事务管理" class="headerlink" title="4. XML声明式事务管理"></a>4. XML声明式事务管理</h3><ul>
<li><p>在Spring配置文件中进行配置</p>
<ol>
<li><p>配置事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 创建事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置通知</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2. 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accountMoney&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置切入点和切面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3. 配置切入点和切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.atguigu.spring5.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="5-完全注解声明式事务管理"><a href="#5-完全注解声明式事务管理" class="headerlink" title="5. 完全注解声明式事务管理"></a>5. 完全注解声明式事务管理</h3><ul>
<li><p>创建配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span> <span class="comment">// 开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">getDruidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line"></span><br><span class="line">        druidDataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring&quot;</span>);</span><br><span class="line">        druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        druidDataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建JdbcTemplate对象</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;jdbcTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line"></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        DataSourceTransactionManager dataSourceTransactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line"></span><br><span class="line">        dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记（一）</title>
    <url>/2021/04/25/springmvc-note-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-MVC回顾"><a href="#1-MVC回顾" class="headerlink" title="1. MVC回顾"></a>1. MVC回顾</h2><h3 id="1-1-什么是MVC？"><a href="#1-1-什么是MVC？" class="headerlink" title="1.1 什么是MVC？"></a>1.1 什么是MVC？</h3><ul>
<li>MVC是模型（Model）、视图（View）、控制器（Controller）的简写，是一种软件设计规范</li>
<li>是将业务逻辑、数据、显示分离的方法来组织代码</li>
<li>MVC主要作用是<strong>降低了视图与业务逻辑的双向耦合</strong></li>
<li>MVC不是一种设计模式，MVC是一种架构模式</li>
</ul>
<h3 id="1-2-MVC框架要做哪些事情"><a href="#1-2-MVC框架要做哪些事情" class="headerlink" title="1.2 MVC框架要做哪些事情"></a>1.2 MVC框架要做哪些事情</h3><ol>
<li>将url映射到Java类或Java类的方法</li>
<li>封装用户提交的数据</li>
<li>处理请求 -&gt; 调用相关的业务处理 -&gt; 封装响应数据</li>
<li>将响应的数据进行渲染（.jsp/.html）等表示层数据</li>
</ol>
<h3 id="1-3-常见的MVC框架"><a href="#1-3-常见的MVC框架" class="headerlink" title="1.3 常见的MVC框架"></a>1.3 常见的MVC框架</h3><ul>
<li>服务器端MVC框架有：Struts、SpringMVC、ASP.NET、Zend Framework、JSF</li>
<li>前端MVC框架有：vue、angularjs、react、backbone</li>
<li>由MVC演化出了另外一些模式：MVP、MVVM等</li>
</ul>
<h2 id="2-什么是SpringMVC"><a href="#2-什么是SpringMVC" class="headerlink" title="2. 什么是SpringMVC"></a>2. 什么是SpringMVC</h2><h3 id="2-1-SpringMVC概述"><a href="#2-1-SpringMVC概述" class="headerlink" title="2.1 SpringMVC概述"></a>2.1 SpringMVC概述</h3><ul>
<li>SpringMVC是SpringFramework的一部分，是基于Java实现MVC的轻量级Web框架</li>
</ul>
<h3 id="2-2-SpringMVC的特点"><a href="#2-2-SpringMVC的特点" class="headerlink" title="2.2 SpringMVC的特点"></a>2.2 SpringMVC的特点</h3><ul>
<li>轻量级，简单易学</li>
<li>高校，基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝缝合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、主题等</li>
<li>简洁灵活</li>
</ul>
<p>Spring的Web框架围绕DispatcherServlet[调度Servlet]设计</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring2.5开始，使用Java5及以上版本的用户可以采用基于注解形式进行开发</p>
<h2 id="3-SpringMVC"><a href="#3-SpringMVC" class="headerlink" title="3. SpringMVC"></a>3. SpringMVC</h2><h3 id="3-1-中心控制器"><a href="#3-1-中心控制器" class="headerlink" title="3.1 中心控制器"></a>3.1 中心控制器</h3><p>Spring的Web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring2.5开始，Java5版本以上的用户可以使用基于注解的Controller声明方式</p>
<p>Spring MVC框架像许多其他MVC框架一样，<strong>以请求为驱动，围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet（继承HttpServlet类）</strong></p>
<p>SpringMVC的原理如下图所示：</p>
<ul>
<li><p>当发起请求时被前置控制器拦截到请求，根据参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应返回给中心控制器，控制器使用模型与视图渲染结果，将结果返回给中心控制器，再将结果返回给请求者</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1619488855.png" alt=""></p>
</li>
</ul>
<h3 id="3-2-SpringMVC执行原理"><a href="#3-2-SpringMVC执行原理" class="headerlink" title="3.2 SpringMVC执行原理"></a>3.2 SpringMVC执行原理</h3><p>图为中实线表示S平日那个MVC框架提供的技术（不需要开发者实现），虚线表示需要开发者实现</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/1619489755.png" alt=""></p>
<p><strong>分析执行流程：</strong></p>
<ol>
<li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求</li>
<li>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping，HandlerMapping根据请求url查找Handler</li>
<li>HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器</li>
<li>HandlerExecution将解析后的信息传递给DispatcherServlet</li>
<li>handlerAdapter表示处理器适配器，其按照特定的规则去执行Handler</li>
<li>Handler让具体的Controller执行</li>
<li>Controller将具体的执行信息（ModelAndView）返回给HandlerAdapter</li>
<li>HandlerAdapter将试图逻辑名或模型传递给DispatcherServlet</li>
<li>DispatcherServlet效用视图解析器（ViewResolver）来解析HandlerAdapter传递的逻辑视图名</li>
<li>视图解析器将解析的逻辑视图名传递给DispatcherServlet</li>
<li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图</li>
<li>最终视图呈现给用户</li>
</ol>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记（五）</title>
    <url>/2021/04/30/springmvc-note-5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-拦截器"><a href="#1-拦截器" class="headerlink" title="1. 拦截器"></a>1. 拦截器</h2><h3 id="1-1-拦截器和过滤器"><a href="#1-1-拦截器和过滤器" class="headerlink" title="1.1 拦截器和过滤器"></a>1.1 拦截器和过滤器</h3><p>SpringMVC的处理器拦截器类似于Servlet开发过程中的过滤器Filter，用于对处理器进行预处理和后处理。我们可以自定义一些拦截器来实现特定的功能</p>
<p>过滤器和拦截器的区别：<strong>拦截器是AOP思想的具体应用</strong></p>
<p>过滤器：</p>
<ul>
<li>Servlet规范中的一部分，任何JavaWeb工程都可以使用</li>
<li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
<p>拦截器：</p>
<ul>
<li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li>
<li>拦截器指挥拦截访问的控制器方法，如果访问的是jsp/html/css/img/js是不会进行拦截的</li>
</ul>
<h3 id="1-2-自定义拦截器"><a href="#1-2-自定义拦截器" class="headerlink" title="1.2 自定义拦截器"></a>1.2 自定义拦截器</h3><ol>
<li><p>首先编写一个类，实现HandlerInterceptor接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在业务处理器处理请求之前被调用</span></span><br><span class="line"><span class="comment">     * 如果返回false</span></span><br><span class="line"><span class="comment">     *     从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链</span></span><br><span class="line"><span class="comment">     * 如果返回true</span></span><br><span class="line"><span class="comment">     *    执行下一个拦截器,直到所有的拦截器都执行完毕</span></span><br><span class="line"><span class="comment">     *    再执行被拦截的Controller</span></span><br><span class="line"><span class="comment">     *    然后进入拦截器链,</span></span><br><span class="line"><span class="comment">     *    从最后一个拦截器往回执行所有的postHandle()</span></span><br><span class="line"><span class="comment">     *    接着再从最后一个拦截器往回执行所有的afterCompletion()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------处理前------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在业务处理器处理请求执行完成后,生成视图之前执行的动作</span></span><br><span class="line"><span class="comment">     * 可在modelAndView中加入数据，比如当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------处理后------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------清理------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在springmvc配置文件中配置拦截器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--关于拦截器的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--/** 包括路径及其子路径--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--/admin/** 拦截的是/admin/下的所有--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--bean配置的就是拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-文件上传下载"><a href="#2-文件上传下载" class="headerlink" title="2. 文件上传下载"></a>2. 文件上传下载</h2><h3 id="2-1-上传"><a href="#2-1-上传" class="headerlink" title="2.1 上传"></a>2.1 上传</h3><ol>
<li><p>首先，表单中的<code>enctype</code>属性要设置为<code>multipart/form-data</code>，只有用这种方式，才会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数种，不会对字符进行编码，其他的一些格式：</p>
<ul>
<li>application/x-www=form-urlencoded：默认方式，只处理表单中的value属性值，采用这种编码方式的表单会将表单域中的值处理成url编码方式</li>
<li>text/plain：处理个空格转换为’<code>+</code>‘外，对其他字符都不做编码处理</li>
</ul>
</li>
<li><p>然后导入相关jar包，commons-fileupload</p>
</li>
<li><p><strong>配置bean：</strong>multipartResolver</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传配置，id必须为multipartResolver--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CommonsMultipartFile 的 常用方法：</p>
<ul>
<li><strong>String getOriginalFilename()：</strong>获取上传文件的原名</li>
<li><strong>InputStream getInputStream()：</strong>获取文件流</li>
<li><strong>void transferTo(File dest)：</strong>将上传文件保存到一个目录文件中</li>
</ul>
</li>
<li><p>编写Controller控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象</span></span><br><span class="line">    <span class="comment">//批量上传CommonsMultipartFile则为数组即可</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file , HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//获取文件名 : file.getOriginalFilename();</span></span><br><span class="line">        String uploadFileName = file.getOriginalFilename();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果文件名为空，直接回到首页！</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(uploadFileName))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件名 : &quot;</span>+uploadFileName);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//上传路径保存设置</span></span><br><span class="line">        String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        <span class="comment">//如果路径不存在，创建一个</span></span><br><span class="line">        File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">            realPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件保存地址：&quot;</span>+realPath);</span><br><span class="line"> </span><br><span class="line">        InputStream is = file.getInputStream(); <span class="comment">//文件输入流</span></span><br><span class="line">        OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(realPath,uploadFileName)); <span class="comment">//文件输出流</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//读取写出</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者采用<code>file.Transto</code>来上传文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String  <span class="title">fileUpload2</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上传路径保存设置</span></span><br><span class="line">    String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">    <span class="comment">//上传文件地址</span></span><br><span class="line">    File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">        realPath.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span></span><br><span class="line">    file.transferTo(<span class="keyword">new</span> File(realPath +<span class="string">&quot;/&quot;</span>+ file.getOriginalFilename()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-2-下载"><a href="#2-2-下载" class="headerlink" title="2.2 下载"></a>2.2 下载</h3><p><strong>文件下载步骤：</strong></p>
<ol>
<li>设置response响应头</li>
<li>读取文件 -&gt; InputStream</li>
<li>写出文件 -&gt; OutputStream</li>
<li>执行操作</li>
<li>关闭流</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/download&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">downloads</span><span class="params">(HttpServletResponse response ,HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//要下载的图片地址</span></span><br><span class="line">    String  path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">    String  fileName = <span class="string">&quot;基础语法.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、设置response 响应头</span></span><br><span class="line">    response.reset(); <span class="comment">//设置页面不缓存,清空buffer</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//字符编码</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;multipart/form-data&quot;</span>); <span class="comment">//二进制传输数据</span></span><br><span class="line">    <span class="comment">//设置响应头</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;attachment;fileName=&quot;</span>+URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">    <span class="comment">//2、 读取文件--输入流</span></span><br><span class="line">    InputStream input=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    <span class="comment">//3、 写出文件--输出流</span></span><br><span class="line">    OutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buff =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//4、执行 写出操作</span></span><br><span class="line">    <span class="keyword">while</span>((index= input.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">        out.write(buff, <span class="number">0</span>, index);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Srping笔记（四）</title>
    <url>/2021/03/26/spring-note-4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、JdbcTemplate概念及使用"><a href="#一、JdbcTemplate概念及使用" class="headerlink" title="一、JdbcTemplate概念及使用"></a>一、JdbcTemplate概念及使用</h2><h3 id="1-什么是JdbcTemplate："><a href="#1-什么是JdbcTemplate：" class="headerlink" title="1. 什么是JdbcTemplate："></a>1. 什么是JdbcTemplate：</h3><ul>
<li>Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库的操作</li>
</ul>
<h3 id="2-使用步骤："><a href="#2-使用步骤：" class="headerlink" title="2. 使用步骤："></a>2. 使用步骤：</h3><ol>
<li><p>引入相关jar包</p>
</li>
<li><p>在spring配置文件中配置数据库连接池</p>
<p><strong>jdbc.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p><strong>bean1.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置JdbcTemplate对象，注入DataSource</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建JdbcTemplate对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建service类、dao类，在dao中注入JdbcTemplate、在service中注入dao</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入 dao</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入 JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二、JdbcTemplate操作数据库"><a href="#二、JdbcTemplate操作数据库" class="headerlink" title="二、JdbcTemplate操作数据库"></a>二、JdbcTemplate操作数据库</h2><h3 id="1-添加"><a href="#1-添加" class="headerlink" title="1. 添加"></a>1. 添加</h3><ol>
<li><p>对应数据库创建实体类</p>
</li>
<li><p>编写service和dao</p>
<ol>
<li><p>在dao中进行数据库的添加操作</p>
</li>
<li><p>调用JdbcTemplate对象里面的update方法实现添加操作</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210326114648349.png" alt=""></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入 JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="comment">//添加的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建 sql 语句</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into t_book values(?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="comment">//2 调用方法实现</span></span><br><span class="line">        Object[] args = &#123;book.getUserId(), book.getUsername(),book.getUstatus()&#125;;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql,args);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-修改和删除"><a href="#2-修改和删除" class="headerlink" title="2. 修改和删除"></a>2. 修改和删除</h3><ul>
<li><p>使用JdbcTemplate 模板所实现的<code>增删改</code>都是调用了同一个 <code>update</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;update t_book set username=?, ustatus=? where user_id=?&quot;</span>;</span><br><span class="line">    Object[] args = &#123;book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class="line">    <span class="keyword">int</span> update = jdbcTemplate.update(sql, args);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> update = jdbcTemplate.update(sql, id);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-查询返回某个值"><a href="#3-查询返回某个值" class="headerlink" title="3. 查询返回某个值"></a>3. 查询返回某个值</h3><ul>
<li><p>查询表里又多少条记录，返回的是一个值</p>
</li>
<li><p>使用JdbcTemplate实现查询返回某个值</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210326115344780.png" alt=""></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询表记录数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line">    <span class="comment">//queryForObject方法中：第一个参数代表--sql语句；第二个参数代表--返回类型class  </span></span><br><span class="line">    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-查询返回对象"><a href="#4-查询返回对象" class="headerlink" title="4. 查询返回对象"></a>4. 查询返回对象</h3><ul>
<li><p>使用JdbcTemplate实现查询返回对象</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210326115622624.png" alt=""></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询返回对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBookInfo</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select * from t_book where user_id=?&quot;</span>;</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    Book book = jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Book&gt;(Book.class), id);</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-查询返回集合"><a href="#5-查询返回集合" class="headerlink" title="5. 查询返回集合"></a>5. 查询返回集合</h3><ul>
<li><p>使用JdbcTemplate实现查询返回集合</p>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210326115831077.png" alt=""></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所用场景：查询图书列表分页、、</span></span><br><span class="line"><span class="comment">//查询返回集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findAllBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    List&lt;Book&gt; bookList = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Book&gt;(Book.class));</span><br><span class="line">    <span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-批量操作"><a href="#6-批量操作" class="headerlink" title="6. 批量操作"></a>6. 批量操作</h3><ul>
<li>概念：操作表里多条记录</li>
<li>JdbcTemplate实现批量操作</li>
</ul>
<p><img src="https://gitee.com/linzeliang1222/picture/raw/master/image-20210326120053965.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line">    <span class="comment">//batchUpdate方法 第一个参数：sql语句		第二个参数：List集合，添加多条记录数据</span></span><br><span class="line">    <span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量添加测试</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;5&quot;</span>,<span class="string">&quot;MySQL&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用批量添加</span></span><br><span class="line">bookService.batchAdd(batchArgs);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>批量修改操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量修改(同批量添加一样，调用同一个方法)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdateBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
